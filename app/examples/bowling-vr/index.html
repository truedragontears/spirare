<!DOCTYPE html>
<html>

<head>

<title>Bowling in VR</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<link rel="stylesheet" type="text/css" href="css/main.css">
</head>

<body>
    <div id="viewport"></div>

	<script>
	/*
	 * Debug parameters.
	 */
	WebVRConfig = {
	  /**
	   * webvr-polyfill configuration
	   */

	  // Forces availability of VR mode.
	  //FORCE_ENABLE_VR: true, // Default: false.
	  // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
	  //K_FILTER: 0.98, // Default: 0.98.
	  // How far into the future to predict during fast motion.
	  //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
	  // Flag to disable touch panner. In case you have your own touch controls
	  //TOUCH_PANNER_DISABLED: true, // Default: false.
	  // Enable yaw panning only, disabling roll and pitch. This can be useful for
	  // panoramas with nothing interesting above or below.
	  //YAW_ONLY: true, // Default: false.
	  // Enable the deprecated version of the API (navigator.getVRDevices).
	  //ENABLE_DEPRECATED_API: true, // Default: false.
	  // Scales the recommended buffer size reported by WebVR, which can improve
	  // performance. Making this very small can lower the effective resolution of
	  // your scene.
	  BUFFER_SCALE: 0.5, // default: 1.0
	  // Allow VRDisplay.submitFrame to change gl bindings, which is more
	  // efficient if the application code will re-bind it's resources on the
	  // next frame anyway.
	  // Dirty bindings include: gl.FRAMEBUFFER_BINDING, gl.CURRENT_PROGRAM,
	  // gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING,
	  // and gl.TEXTURE_BINDING_2D for texture unit 0
	  // Warning: enabling this might lead to rendering issues.
	  //DIRTY_SUBMIT_FRAME_BINDINGS: true // default: false
	};
	</script>

	<!-- A polyfill for Promises. Needed for IE and Edge. -->
	<script src="js/libs/es6-promise.js"></script>

	<!-- three.js 3d library -->
	<script src="js/libs/three.js"></script>

	<!-- VRControls.js acquires positional information from connected VR devices
	and applies the transformations to a three.js camera object.  -->
	<script src="js/libs/VRControls.js"></script>

	<!-- VREffect.js handles stereo camera setup and rendering.  -->
	<script src="js/libs/VREffect.js"></script>

	<!-- A polyfill for WebVR using the Device{Motion,Orientation}Event API. -->
	<script src="js/libs/webvr-polyfill.js"></script>

	<!-- Helps enter and exit VR mode, provides best practices while in VR.  -->
	<script src="js/libs/webvr-manager.js"></script>

	<!-- threejs render stats widget -->
	<script type="text/javascript" src="js/libs/stats.js"></script>

	<!-- PhysiJS physics engine -->
	<script type="text/javascript" src="js/libs/physi.js"></script>

	<script type="text/javascript">
	  Physijs.scripts.worker = 'js/libs/physijs_worker.js';
	  Physijs.scripts.ammo = 'ammo.js';
	</script>

	<script>

	var renderer, scene, camera, ground;
	var ball, ballVelocity;
	var groundFriction = 0.9, groundRestitution = 0.1;

	var createBowlingPins = function( firstPinPositionX, firstPinPositionY, firstPinPositionZ, spacing, rows ) {

		for ( var i = 1; i <= rows; i ++ ) {

			var even = ( i % 2 == 0 );

			for ( var nPins = 0; nPins < i; nPins ++ ) {

				if ( even ) var offset = ( i / 2 * spacing ) - spacing / 2;
				if ( ! even ) var offset = ( i / 2 - 0.5 ) * spacing;
				var pin = new Physijs.BoxMesh( new THREE.CubeGeometry( 2, 5, 2 ), new THREE.MeshNormalMaterial(), 0.1 );
				pin.position.set( offset - nPins * spacing, firstPinPositionY, i * - spacing );
				scene.add( pin );

			}

		}

	}




	// Setup three.js WebGL renderer. Note: Antialiasing is a big performance hit.
	// Only enable it if you actually need to.
	var renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setPixelRatio(window.devicePixelRatio);

	// Append the canvas element created by the renderer to document body element.
	document.body.appendChild(renderer.domElement);

	// Create a three.js scene.
	//var scene = new THREE.Scene();
        scene = new Physijs.Scene;
        scene.setGravity( new THREE.Vector3( 0, -50, 0 ) );

	// Create a three.js camera.
	var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

	// Apply VR headset positional data to camera.
	var controls = new THREE.VRControls(camera);
	controls.standing = true;

	// Apply VR stereo rendering to renderer.
	var effect = new THREE.VREffect(renderer);
	effect.setSize(window.innerWidth, window.innerHeight);

        ground = new Physijs.BoxMesh(
          new THREE.CubeGeometry( 1000, 1, 1000 ),
          Physijs.createMaterial( new THREE.MeshBasicMaterial( { color: 0x888888 } ),
          groundFriction, groundRestitution ),
          0
        );

        ground.name = "ground";
        ground.position.set( 0, 0, 0 );
        scene.add( ground );

        createBowlingPins( 0, 3, 0, 10, 4 );

	// Add a repeating grid as a skybox.
	var boxSize = 5;
	var loader = new THREE.TextureLoader();
	loader.load('img/box.png', onTextureLoaded);

	function onTextureLoaded(texture) {
	  texture.wrapS = THREE.RepeatWrapping;
	  texture.wrapT = THREE.RepeatWrapping;
	  texture.repeat.set(boxSize, boxSize);

	  var geometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
	  var material = new THREE.MeshBasicMaterial({
	    map: texture,
	    color: 0x01BE00,
	    side: THREE.BackSide
	  });

	  // Align the skybox to the floor (which is at y=0).
	  skybox = new THREE.Mesh(geometry, material);
	  skybox.position.y = boxSize/2;
	  //scene.add(skybox);

	  // For high end VR devices like Vive and Oculus, take into account the stage
	  // parameters provided.
	  setupStage();
	}


	// Create a VR manager helper to enter and exit VR mode.
	var params = {
	  hideButton: false, // Default: false.
	  isUndistorted: false // Default: false.
	};

	var manager = new WebVRManager(renderer, effect, params);

	// Create 3D objects.
	var geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
	var material = new THREE.MeshNormalMaterial();
	var cube = new THREE.Mesh(geometry, material);

	// Position cube mesh to be right in front of you.
	cube.position.set(0, controls.userHeight, -1);

        ball = new Physijs.SphereMesh(
          new THREE.SphereGeometry( 2, 10, 10 ),
          new THREE.MeshNormalMaterial(),
          1
        );

        ball.position.set( 0, 3, 20 );
        scene.add( ball );
        ball.applyCentralImpulse( new THREE.Vector3( 0, 0, - 100 ) );

	// Add cube mesh to your three.js scene
	//scene.add(cube);

	// Kick off animation loop
	requestAnimationFrame(animate);

	window.addEventListener('resize', onResize, true);
	window.addEventListener('vrdisplaypresentchange', onResize, true);

	// Request animation frame loop function
	var lastRender = 0;

	function animate(timestamp) {
	  var delta = Math.min(timestamp - lastRender, 500);
	  lastRender = timestamp;

	  // Apply rotation to cube mesh
	  cube.rotation.y += delta * 0.0006;

	  // Update VR headset position and apply to camera.
	  controls.update();

	  // run physics
	  scene.simulate();

	  // Render the scene through the manager.
	  manager.render(scene, camera, timestamp);

	  requestAnimationFrame(animate);
	}

	function onResize(e) {
	  effect.setSize(window.innerWidth, window.innerHeight);
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	}

	var display;

	// Get the HMD, and if we're dealing with something that specifies
	// stageParameters, rearrange the scene.
	function setupStage() {
	  navigator.getVRDisplays().then(function(displays) {
	    if (displays.length > 0) {
	      display = displays[0];
	      if (display.stageParameters) {
		setStageDimensions(display.stageParameters);
	      }
	    }
	  });
	}

	function setStageDimensions(stage) {
	  // Make the skybox fit the stage.
	  var material = skybox.material;
	  scene.remove(skybox);

	  // Size the skybox according to the size of the actual stage.
	  var geometry = new THREE.BoxGeometry(stage.sizeX, boxSize, stage.sizeZ);
	  skybox = new THREE.Mesh(geometry, material);

	  // Place it on the floor.
	  skybox.position.y = boxSize/2;
	  scene.add(skybox);

	  // Place the cube in the middle of the scene, at user height.
	  cube.position.set(0, controls.userHeight, 0);
	}

	</script>

    <!--script type="text/javascript" src="js/init.js"></script-->
    <!--script type="text/javascript"> window.onload = initScene(); </script-->

</body>
</html>
